/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"
#include <stdio.h>
#include <string.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
typedef struct {
	USART_TypeDef *USARTx; //npr. USART1 ali USART2...
	uint32_t COM_SPEED;    //npr. 115200 ali 9600,...
	GPIO_TypeDef *TX_PORT; //npr. GPIOA  ali GPIOB, ...
	uint8_t TX_PIN;        //npr. pin 0  ali pin 1, ....W
	GPIO_TypeDef *RX_PORT; //npr. GPIOA  ali GPIOB, ...W
	uint8_t RX_PIN;        //npr. pin 0  ali pin 1, ....
} myUart_TypeDdef;

void myUART_Init(myUart_TypeDdef *uart_x) {
    // Nastavitev ur za GPIO in USART
    if (uart_x->TX_PORT == GPIOA) {
        RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    }
    // Dodajte podobne pogoje za druge porte, če so potrebni

    if (uart_x->USARTx == USART2) {
        RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
    }
    // Dodajte podobne pogoje za druge USART vmesnike, če so potrebni

    // Konfiguracija pinov za TX in RX
    uart_x->TX_PORT->MODER |= (0x2 << (2 * uart_x->TX_PIN)); // Alternativna funkcija
    uart_x->TX_PORT->AFR[0] |= (0x7 << (4 * uart_x->TX_PIN)); // AF7 (USART2 na pinu A2)
    uart_x->RX_PORT->MODER |= (0x2 << (2 * uart_x->RX_PIN)); // Alternativna funkcija
    uart_x->RX_PORT->AFR[0] |= (0x7 << (4 * uart_x->RX_PIN)); // AF7 (USART2 na pinu A3)

    // Nastavitev parametrov USART
    uart_x->USARTx->BRR = 16000000 / uart_x->COM_SPEED; // Nastavitev baud rate (predpostavka 16MHz ura)
    uart_x->USARTx->CR1 = USART_CR1_TE | USART_CR1_RE; // Omogoči TX in RX
    uart_x->USARTx->CR1 |= USART_CR1_UE; // Omogoči USART
}

void myUART_Tx(USART_TypeDef *USARTx, uint8_t* tx_buff, uint32_t tx_len) {
    for (uint32_t i = 0; i < tx_len; i++) {
        while (!(USARTx->SR & USART_SR_TXE)); // Čakaj, da je predpomnilnik prazen
        USARTx->DR = tx_buff[i]; // Pošlji znak
    }
    while (!(USARTx->SR & USART_SR_TC)); // Čakaj na dokončanje prenosa
}

void myUART_Rx(USART_TypeDef *USARTx, uint8_t* rx_buff, uint32_t rx_len, uint8_t end_char) {
    uint32_t i = 0;
    while (i < rx_len || rx_len == 0) {
        while (!(USARTx->SR & USART_SR_RXNE)); // Čakaj na prispelek znaka
        rx_buff[i] = USARTx->DR; // Preberi znak
        if (rx_len == 0 && rx_buff[i] == end_char) break; // Prekinitev, če je prejet končni znak
        i++;
    }
}


uint8_t tx_buf[]= "Test funkcije za pošiljanje\n";
uint8_t rx_buf[100]; //Polje za sprejem zankov
*/

void USART2_Write(int ch) {
    // Wait while TX buffer is empty
    while (!(USART2->SR & 0x0080)) {}
    USART2->DR = (ch & 0xFF);
}

void delayMs(int delay) {
    int i;
    for (; delay > 0; delay--) {
        for (i = 0; i < 3195; i++); // Delay
    }
}

int main(void)
{
	/*
	myUart_TypeDdef myUsart2;
	myUsart2.USARTx = USART2;
	myUsart2.COM_SPEED = 115200U;
	myUsart2.TX_PORT = GPIOA;
	myUsart2.TX_PIN = 2;
	myUsart2.RX_PORT = GPIOA;
	myUsart2.RX_PIN = 3;

	myUART_Init(&myUsart2);

	myUART_Tx(USART2,tx_buf,strlen((char*)tx_buf)); //Pošlje niz tx_bufff
	//myUART_Rx(USART2, rx_buf, 0, '\n'); //Sprejem znakov se zaključi z znakom '\n'
	myUART_Rx(USART2, rx_buf, 5, '\n'); //Sprejem znakov se zaključi po 5 znakih
	*/

	/*
	RCC->AHB1ENR |= 1; // Enable GPIOA clock
	    RCC->APB1ENR |= 0x20000; // Enable USART2 clock

	    // Configure PA2, PA3 for USART2
	    GPIOA->AFR[0] |= 0x7700; // Alt7 for USART2
	    GPIOA->MODER |= 0x00A0; // Enable alternate function for PA2, PA3

	    USART2->BRR = 0x0683; // Set baud rate to 9600 @ 16 MHz
	    USART2->CR1 = 0x000C; // Enable Tx, Rx, 8-bit data
	    USART2->CR2 = 0x0000; // 1 Stop bit
	    USART2->CR3 = 0x0000; // No flow control
	    USART2->CR1 |= 0x2000; // Enable USART2
	*/

	//init start
	*AHB1ENR |= 1 << 0;					// GPIOA clock enable
		APB1ENR |= 1 << 17; 				//USART2 clock enable

		GPIOA->MODER |= 2 << 4;					//PA2 je alternate function
		GPIOA->MODER |= 2 << 6; 				//PA3 je alternate function

		GPIOA->AFRL |= 7 << 8;					//USART2 povezan na PA2
		GPIOA->AFRL |= 7 << 12; 				//USART2 povezan na PA3

		USART2->CR1 &= ~(1 << 13); 				//onemogocimo USART napravo, vse bite damo na 0

		USART2->CR1 |= 1 << 2; 					//receiver enabled
		USART2->CR1 |= 1 << 3; 					//transmiter enabled

		//baud rate moramo zracunati z enacbo
		  //8,68
	//	*USART2_BRR = 8 << 4;
		  //0,68 * 16 = 10,88 priblizno 11 za decimalno vrednost
	//	*USART2_BRR |= 0xb; //11
		  //s tem nastavimo baud rate na 115200
		USART2->BRR |= 0x8B;

		//  NVIC_EnableIRQ(USART2_IRQn);
		  //NVIC->ISER[38/32] |= 1 << (38 % 32); //prvi del izbere register, drugi del pa bit

		USART2->CR1 |= 1 << 13; 				//USART (naprava) enabled

		USART2->CR1 |= (1 << 5); 				// RXNE interrupt - povemo, naj RXNE prozi prekinitev
		NVIC->ISER[38/32] |= 1 << (38 % 32); 	// Omogocimo prekinitev z njeno stevilko - USART

		EXTI->IMR |= 1 << 0; 					// Povemo, naj gumb prozi prekinitev
		EXTI->RTSR |= 1 << 0;                	// Rising-edge sprozi prekinitev
		EXTI->FTSR &= ~(1 << 0);             	// Falling edge ne sprozi prekinitve
		NVIC->ISER[6/32] |= 1 << (6 % 32);   	// Omogocimo prekinitev z njeno stevilko - BUTTON - EXTI
		//end


	    while(1) {
	    	/*
	            USART2_Write('H'); // Send 'H'
	            USART2_Write('e'); // Send 'e'
	            USART2_Write('l'); // Send 'l'
	            USART2_Write('l'); // Send 'l'
	            USART2_Write('o'); // Send 'o'
	            USART2_Write('\r'); // Send carriage return
	            USART2_Write('\n'); // Send newline

	            delayMs(1000); // Wait for a while
	    	 */
	        }



	 /* Loop forever */
	//for(;;);
}

